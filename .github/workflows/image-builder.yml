name: 'Image Builder and VMSS Provisioning'

on:
  workflow_dispatch:
    inputs:
      image_name:
        description: 'Name of the gallery image to use'
        required: true
        default: 'java-tomcat-image'
        type: string
      os_type:
        description: 'OS type: linux or windows'
        required: true
        default: 'linux'
        type: choice
        options:
          - linux
          - windows
      kv_name:
        description: 'Azure Key Vault name'
        required: true
        default: 'rgdevazurevmimagesmgmtkv'
        type: string    

env:
  RESOURCE_GROUP: 'rg-dev-azure-vm-images-mgmt'
  GALLERY_NAME: 'rgdevazurevmimagesmgmtga'
  LOCATION: 'westeurope'

jobs:
  provision-vmss:
    runs-on: ubuntu-latest  # Use Linux runner for Azure CLI

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Get Public IP
      run: |
        PUBLIC_IP=$(curl -s https://api.ipify.org)
        echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV
        echo "Allowed IP: $PUBLIC_IP"

    - name: Update Key Vault Network ACLs
      run: |
        KV_NAME="${{ inputs.kv_name }}"
        if [ -z "$KV_NAME" ]; then
          KV_NAME="rgdevazurevmimagesmgmtkv"
        fi
        if az keyvault show --name $KV_NAME --query name -o tsv >/dev/null 2>&1; then
          echo "Key Vault $KV_NAME exists. Adding IP $PUBLIC_IP to allowed IPs."
          az keyvault network-rule add --name $KV_NAME --ip-address "$PUBLIC_IP/32"
        else
          echo "Key Vault $KV_NAME does not exist. Skipping IP whitelisting."
        fi

    - name: Check Managed Image Existence
      run: |
        managed_image_name="${{ inputs.image_name }}-managed"
        if az image show --resource-group ${{ env.RESOURCE_GROUP }} --name $managed_image_name >/dev/null 2>&1; then
          echo "Managed image $managed_image_name exists. Proceeding with version creation."
          echo "MANAGED_IMAGE_EXISTS=true" >> $GITHUB_ENV
        else
          echo "Managed image $managed_image_name does not exist. Skipping version creation."
          echo "MANAGED_IMAGE_EXISTS=false" >> $GITHUB_ENV
        fi

    - name: Create Image Version
      if: env.MANAGED_IMAGE_EXISTS == 'true'
      run: |
        end_of_life=$(date -u -d '+1 month' +%Y-%m-%d)
        subscription_id=$(az account show --query id -o tsv)
        source_image_id="/subscriptions/$subscription_id/resourceGroups/${{ env.RESOURCE_GROUP }}/providers/Microsoft.Compute/images/${{ inputs.image_name }}-managed"
        az sig image-version create \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --gallery-name ${{ env.GALLERY_NAME }} \
          --gallery-image-definition ${{ inputs.image_name }} \
          --gallery-image-version "1.0.0" \
          --managed-image $source_image_id \
          --end-of-life-date $end_of_life \
          --target-regions "${{ env.LOCATION }}=1"
      shell: bash

    - name: Get Image ID
      run: |
        IMAGE_ID=$(az sig image-version show \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --gallery-name ${{ env.GALLERY_NAME }} \
          --gallery-image-definition ${{ inputs.image_name }} \
          --gallery-image-version "1.0.0" \
          --query "id" -o tsv)
        echo "IMAGE_ID=$IMAGE_ID" >> $GITHUB_ENV

    - name: Provision VMSS
      run: |
        if [ "${{ inputs.os_type }}" = "linux" ]; then
          az vmss create \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name "${{ env.RESOURCE_GROUP }}-vmss" \
            --image $IMAGE_ID \
            --admin-username "adminuser" \
            --generate-ssh-keys \
            --public-ip-per-vm \
            --nsg "rgdevazurevmimagesmgmtkv-nsg" \
            --instance-count 1 \
            --vm-sku "Standard_B1s" \
            --location ${{ env.LOCATION }}
        else
          PASSWORD=$(az keyvault secret show \
            --vault-name "rgdevazurevmimagesmgmtkv" \
            --name "admin-password" \
            --query "value" -o tsv)
          az vmss create \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name "${{ env.RESOURCE_GROUP }}-vmss" \
            --image $IMAGE_ID \
            --admin-username "adminuser" \
            --admin-password $PASSWORD \
            --public-ip-per-vm \
            --nsg "rgdevazurevmimagesmgmtkv-nsg" \
            --instance-count 1 \
            --vm-sku "Standard_B1s" \
            --location ${{ env.LOCATION }}
        fi

    - name: Get VMSS Public IP
      run: |
        PUBLIC_IP=$(az network public-ip list \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --query "[?contains(name, '${{ env.RESOURCE_GROUP }}-vmss')].ipAddress" \
          -o tsv | head -1)
        echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV

    - name: Test Connectivity
      run: |
        if [ "${{ inputs.os_type }}" = "linux" ]; then
          # Test SSH
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 adminuser@$PUBLIC_IP "echo 'SSH access successful'"
        else
          # Test RDP (basic connectivity check)
          nc -z $PUBLIC_IP 3389 && echo "RDP port open" || echo "RDP port closed"
        fi

    - name: Wait for VM to be ready
      run: |
        # Wait for VMSS instance to be running
        for i in {1..10}; do
          status=$(az vmss list-instances --resource-group ${{ env.RESOURCE_GROUP }} --name "${{ env.RESOURCE_GROUP }}-vmss" --query "[0].instanceView.statuses[?code=='PowerState/running'].code" -o tsv)
          if [ "$status" = "PowerState/running" ]; then
            echo "VM is running"
            break
          fi
          echo "Waiting for VM to be running... ($i/10)"
          sleep 30
        done

    - name: Test Web Application
      run: |
        # Additional wait for services to start
        sleep 60
        # Test web app on Tomcat default port 8080
        if curl -f --max-time 30 http://$PUBLIC_IP:8080 >/dev/null 2>&1; then
          echo "Web application is accessible"
        else
          echo "Web application test failed"
        fi